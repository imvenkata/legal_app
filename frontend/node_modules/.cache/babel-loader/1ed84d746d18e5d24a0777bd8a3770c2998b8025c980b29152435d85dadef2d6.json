{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n// Import the API function we created\nimport { searchAPI } from '../services/api';\nconst initialState = {\n  documents: [],\n  currentDocument: null,\n  analysis: null,\n  loading: false,\n  error: null,\n  // New state for multi-document upload to search service\n  ingestionUploading: false,\n  ingestionUploadError: null,\n  ingestionUploadProgress: 0,\n  // Placeholder for future progress tracking\n  lastIngestionUploadResult: null // Store the API response\n};\n\n// --- New Async Thunk for Search Service Upload --- \nexport const uploadDocsForIngestion = createAsyncThunk('document/uploadForIngestion', async (formData, {\n  rejectWithValue\n}) => {\n  // formData is expected to be a FormData object with a 'files' key\n  try {\n    // Use the correct API function from searchAPI\n    const response = await searchAPI.uploadLegalDocs(formData);\n    // API returns { message: \"...\", filenames: [...] }\n    return response.data;\n  } catch (error) {\n    var _error$response, _error$response$data;\n    console.error(\"Error uploading documents for ingestion:\", error);\n    const errorMsg = ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.detail) || error.message || 'Failed to upload documents';\n    return rejectWithValue(errorMsg);\n  }\n});\nexport const documentSlice = createSlice({\n  name: 'document',\n  initialState,\n  reducers: {\n    fetchDocumentsStart: state => {\n      state.loading = true;\n      state.error = null;\n    },\n    fetchDocumentsSuccess: (state, action) => {\n      state.loading = false;\n      state.documents = action.payload;\n    },\n    fetchDocumentsFailure: (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    },\n    uploadDocumentStart: state => {\n      state.loading = true;\n      state.error = null;\n    },\n    uploadDocumentSuccess: (state, action) => {\n      state.loading = false;\n      state.documents = [...state.documents, action.payload];\n      state.currentDocument = action.payload;\n    },\n    uploadDocumentFailure: (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    },\n    analyzeDocumentStart: state => {\n      state.loading = true;\n      state.error = null;\n    },\n    analyzeDocumentSuccess: (state, action) => {\n      state.loading = false;\n      state.analysis = action.payload;\n    },\n    analyzeDocumentFailure: (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    },\n    setCurrentDocument: (state, action) => {\n      state.currentDocument = action.payload;\n    },\n    clearAnalysis: state => {\n      state.analysis = null;\n    },\n    clearError: state => {\n      state.error = null;\n      state.ingestionUploadError = null; // Clear new error state too\n    },\n    // Add reducer to clear upload status if needed\n    clearIngestionUploadStatus: state => {\n      state.ingestionUploading = false;\n      state.ingestionUploadError = null;\n      state.ingestionUploadProgress = 0;\n      state.lastIngestionUploadResult = null;\n    }\n  },\n  extraReducers: builder => {\n    builder\n    // Handle uploadDocsForIngestion lifecycle\n    .addCase(uploadDocsForIngestion.pending, state => {\n      state.ingestionUploading = true;\n      state.ingestionUploadError = null;\n      state.ingestionUploadProgress = 0;\n      state.lastIngestionUploadResult = null;\n    }).addCase(uploadDocsForIngestion.fulfilled, (state, action) => {\n      state.ingestionUploading = false;\n      state.lastIngestionUploadResult = action.payload; // Store { message, filenames }\n      state.ingestionUploadProgress = 100; // Basic completion indication\n      // Note: We don't modify state.documents here as ingestion happens in the background\n    }).addCase(uploadDocsForIngestion.rejected, (state, action) => {\n      state.ingestionUploading = false;\n      state.ingestionUploadError = action.payload;\n      state.lastIngestionUploadResult = null;\n    });\n    // Add cases for existing thunks if they are converted later\n  }\n});\nexport const {\n  fetchDocumentsStart,\n  fetchDocumentsSuccess,\n  fetchDocumentsFailure,\n  uploadDocumentStart,\n  uploadDocumentSuccess,\n  uploadDocumentFailure,\n  analyzeDocumentStart,\n  analyzeDocumentSuccess,\n  analyzeDocumentFailure,\n  setCurrentDocument,\n  clearAnalysis,\n  clearError,\n  clearIngestionUploadStatus\n} = documentSlice.actions;\n\n// Thunk actions\nexport const fetchDocuments = () => async dispatch => {\n  try {\n    dispatch(fetchDocumentsStart());\n    // In a real app, this would call the API service\n    // const response = await documentService.getDocuments();\n\n    // Simulate API call for demo\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    const response = [{\n      id: '1',\n      title: 'Employment Contract',\n      description: 'Standard employment agreement',\n      file_path: '/documents/employment_contract.pdf',\n      file_type: 'pdf',\n      status: 'analyzed',\n      created_at: new Date().toISOString()\n    }, {\n      id: '2',\n      title: 'Non-Disclosure Agreement',\n      description: 'Confidentiality agreement for project X',\n      file_path: '/documents/nda.pdf',\n      file_type: 'pdf',\n      status: 'uploaded',\n      created_at: new Date().toISOString()\n    }];\n    dispatch(fetchDocumentsSuccess(response));\n    return response;\n  } catch (error) {\n    dispatch(fetchDocumentsFailure(error.message));\n    throw error;\n  }\n};\nexport const uploadDocument = (file, title, description) => async dispatch => {\n  try {\n    dispatch(uploadDocumentStart());\n    // In a real app, this would call the API service\n    // const response = await documentService.uploadDocument(file, title, description);\n\n    // Simulate API call for demo\n    await new Promise(resolve => setTimeout(resolve, 1500));\n    const response = {\n      id: Math.random().toString(36).substring(2, 9),\n      title,\n      description,\n      file_path: `/documents/${file.name}`,\n      file_type: file.name.split('.').pop(),\n      status: 'uploaded',\n      created_at: new Date().toISOString()\n    };\n    dispatch(uploadDocumentSuccess(response));\n    return response;\n  } catch (error) {\n    dispatch(uploadDocumentFailure(error.message));\n    throw error;\n  }\n};\nexport const analyzeDocument = (documentId, llmModel) => async dispatch => {\n  try {\n    dispatch(analyzeDocumentStart());\n    // In a real app, this would call the API service\n    // const response = await documentService.analyzeDocument(documentId, llmModel);\n\n    // Simulate API call for demo\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    const response = {\n      document_id: documentId,\n      summary: \"This contract outlines a service agreement between ABC Corp and XYZ Inc for software development services.\",\n      key_points: [\"Initial term of 12 months with automatic renewal\", \"Payment terms: Net 30 days\", \"Includes confidentiality and non-compete clauses\", \"Intellectual property rights assigned to client\"],\n      entities: {\n        people: [\"John Smith (CEO)\", \"Jane Doe (CTO)\"],\n        organizations: [\"ABC Corporation\", \"XYZ Inc\"],\n        dates: [\"January 15, 2025\", \"December 31, 2025\"]\n      },\n      recommendations: [\"Review section 3.2 regarding payment terms\", \"Consider adding more specific deliverable timelines\", \"Strengthen the dispute resolution mechanism\"],\n      llm_model: llmModel\n    };\n    dispatch(analyzeDocumentSuccess(response));\n    return response;\n  } catch (error) {\n    dispatch(analyzeDocumentFailure(error.message));\n    throw error;\n  }\n};\nexport default documentSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","searchAPI","initialState","documents","currentDocument","analysis","loading","error","ingestionUploading","ingestionUploadError","ingestionUploadProgress","lastIngestionUploadResult","uploadDocsForIngestion","formData","rejectWithValue","response","uploadLegalDocs","data","_error$response","_error$response$data","console","errorMsg","detail","message","documentSlice","name","reducers","fetchDocumentsStart","state","fetchDocumentsSuccess","action","payload","fetchDocumentsFailure","uploadDocumentStart","uploadDocumentSuccess","uploadDocumentFailure","analyzeDocumentStart","analyzeDocumentSuccess","analyzeDocumentFailure","setCurrentDocument","clearAnalysis","clearError","clearIngestionUploadStatus","extraReducers","builder","addCase","pending","fulfilled","rejected","actions","fetchDocuments","dispatch","Promise","resolve","setTimeout","id","title","description","file_path","file_type","status","created_at","Date","toISOString","uploadDocument","file","Math","random","toString","substring","split","pop","analyzeDocument","documentId","llmModel","document_id","summary","key_points","entities","people","organizations","dates","recommendations","llm_model","reducer"],"sources":["/Users/venkata/startup/legal_app/frontend/src/store/documentSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n// Import the API function we created\nimport { searchAPI } from '../services/api'; \n\nconst initialState = {\n  documents: [],\n  currentDocument: null,\n  analysis: null,\n  loading: false,\n  error: null,\n\n  // New state for multi-document upload to search service\n  ingestionUploading: false,\n  ingestionUploadError: null,\n  ingestionUploadProgress: 0, // Placeholder for future progress tracking\n  lastIngestionUploadResult: null, // Store the API response\n};\n\n// --- New Async Thunk for Search Service Upload --- \nexport const uploadDocsForIngestion = createAsyncThunk(\n  'document/uploadForIngestion',\n  async (formData, { rejectWithValue }) => {\n    // formData is expected to be a FormData object with a 'files' key\n    try {\n      // Use the correct API function from searchAPI\n      const response = await searchAPI.uploadLegalDocs(formData);\n      // API returns { message: \"...\", filenames: [...] }\n      return response.data; \n    } catch (error) {\n      console.error(\"Error uploading documents for ingestion:\", error);\n      const errorMsg = error.response?.data?.detail || error.message || 'Failed to upload documents';\n      return rejectWithValue(errorMsg);\n    }\n  }\n);\n\nexport const documentSlice = createSlice({\n  name: 'document',\n  initialState,\n  reducers: {\n    fetchDocumentsStart: (state) => {\n      state.loading = true;\n      state.error = null;\n    },\n    fetchDocumentsSuccess: (state, action) => {\n      state.loading = false;\n      state.documents = action.payload;\n    },\n    fetchDocumentsFailure: (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    },\n    uploadDocumentStart: (state) => {\n      state.loading = true;\n      state.error = null;\n    },\n    uploadDocumentSuccess: (state, action) => {\n      state.loading = false;\n      state.documents = [...state.documents, action.payload];\n      state.currentDocument = action.payload;\n    },\n    uploadDocumentFailure: (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    },\n    analyzeDocumentStart: (state) => {\n      state.loading = true;\n      state.error = null;\n    },\n    analyzeDocumentSuccess: (state, action) => {\n      state.loading = false;\n      state.analysis = action.payload;\n    },\n    analyzeDocumentFailure: (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    },\n    setCurrentDocument: (state, action) => {\n      state.currentDocument = action.payload;\n    },\n    clearAnalysis: (state) => {\n      state.analysis = null;\n    },\n    clearError: (state) => {\n      state.error = null;\n      state.ingestionUploadError = null; // Clear new error state too\n    },\n    // Add reducer to clear upload status if needed\n    clearIngestionUploadStatus: (state) => {\n        state.ingestionUploading = false;\n        state.ingestionUploadError = null;\n        state.ingestionUploadProgress = 0;\n        state.lastIngestionUploadResult = null;\n    }\n  },\n  extraReducers: (builder) => {\n    builder\n      // Handle uploadDocsForIngestion lifecycle\n      .addCase(uploadDocsForIngestion.pending, (state) => {\n        state.ingestionUploading = true;\n        state.ingestionUploadError = null;\n        state.ingestionUploadProgress = 0;\n        state.lastIngestionUploadResult = null;\n      })\n      .addCase(uploadDocsForIngestion.fulfilled, (state, action) => {\n        state.ingestionUploading = false;\n        state.lastIngestionUploadResult = action.payload; // Store { message, filenames }\n        state.ingestionUploadProgress = 100; // Basic completion indication\n        // Note: We don't modify state.documents here as ingestion happens in the background\n      })\n      .addCase(uploadDocsForIngestion.rejected, (state, action) => {\n        state.ingestionUploading = false;\n        state.ingestionUploadError = action.payload; \n        state.lastIngestionUploadResult = null;\n      });\n      // Add cases for existing thunks if they are converted later\n  }\n});\n\nexport const {\n  fetchDocumentsStart,\n  fetchDocumentsSuccess,\n  fetchDocumentsFailure,\n  uploadDocumentStart,\n  uploadDocumentSuccess,\n  uploadDocumentFailure,\n  analyzeDocumentStart,\n  analyzeDocumentSuccess,\n  analyzeDocumentFailure,\n  setCurrentDocument,\n  clearAnalysis,\n  clearError,\n  clearIngestionUploadStatus\n} = documentSlice.actions;\n\n// Thunk actions\nexport const fetchDocuments = () => async (dispatch) => {\n  try {\n    dispatch(fetchDocumentsStart());\n    // In a real app, this would call the API service\n    // const response = await documentService.getDocuments();\n    \n    // Simulate API call for demo\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    const response = [\n      {\n        id: '1',\n        title: 'Employment Contract',\n        description: 'Standard employment agreement',\n        file_path: '/documents/employment_contract.pdf',\n        file_type: 'pdf',\n        status: 'analyzed',\n        created_at: new Date().toISOString()\n      },\n      {\n        id: '2',\n        title: 'Non-Disclosure Agreement',\n        description: 'Confidentiality agreement for project X',\n        file_path: '/documents/nda.pdf',\n        file_type: 'pdf',\n        status: 'uploaded',\n        created_at: new Date().toISOString()\n      }\n    ];\n    \n    dispatch(fetchDocumentsSuccess(response));\n    return response;\n  } catch (error) {\n    dispatch(fetchDocumentsFailure(error.message));\n    throw error;\n  }\n};\n\nexport const uploadDocument = (file, title, description) => async (dispatch) => {\n  try {\n    dispatch(uploadDocumentStart());\n    // In a real app, this would call the API service\n    // const response = await documentService.uploadDocument(file, title, description);\n    \n    // Simulate API call for demo\n    await new Promise(resolve => setTimeout(resolve, 1500));\n    const response = {\n      id: Math.random().toString(36).substring(2, 9),\n      title,\n      description,\n      file_path: `/documents/${file.name}`,\n      file_type: file.name.split('.').pop(),\n      status: 'uploaded',\n      created_at: new Date().toISOString()\n    };\n    \n    dispatch(uploadDocumentSuccess(response));\n    return response;\n  } catch (error) {\n    dispatch(uploadDocumentFailure(error.message));\n    throw error;\n  }\n};\n\nexport const analyzeDocument = (documentId, llmModel) => async (dispatch) => {\n  try {\n    dispatch(analyzeDocumentStart());\n    // In a real app, this would call the API service\n    // const response = await documentService.analyzeDocument(documentId, llmModel);\n    \n    // Simulate API call for demo\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    const response = {\n      document_id: documentId,\n      summary: \"This contract outlines a service agreement between ABC Corp and XYZ Inc for software development services.\",\n      key_points: [\n        \"Initial term of 12 months with automatic renewal\",\n        \"Payment terms: Net 30 days\",\n        \"Includes confidentiality and non-compete clauses\",\n        \"Intellectual property rights assigned to client\"\n      ],\n      entities: {\n        people: [\"John Smith (CEO)\", \"Jane Doe (CTO)\"],\n        organizations: [\"ABC Corporation\", \"XYZ Inc\"],\n        dates: [\"January 15, 2025\", \"December 31, 2025\"]\n      },\n      recommendations: [\n        \"Review section 3.2 regarding payment terms\",\n        \"Consider adding more specific deliverable timelines\",\n        \"Strengthen the dispute resolution mechanism\"\n      ],\n      llm_model: llmModel\n    };\n    \n    dispatch(analyzeDocumentSuccess(response));\n    return response;\n  } catch (error) {\n    dispatch(analyzeDocumentFailure(error.message));\n    throw error;\n  }\n};\n\nexport default documentSlice.reducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
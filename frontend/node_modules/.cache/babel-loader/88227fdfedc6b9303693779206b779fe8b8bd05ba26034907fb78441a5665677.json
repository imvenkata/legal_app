{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  documents: [],\n  currentDocument: null,\n  analysis: null,\n  loading: false,\n  error: null\n};\nexport const documentSlice = createSlice({\n  name: 'document',\n  initialState,\n  reducers: {\n    fetchDocumentsStart: state => {\n      state.loading = true;\n      state.error = null;\n    },\n    fetchDocumentsSuccess: (state, action) => {\n      state.loading = false;\n      state.documents = action.payload;\n    },\n    fetchDocumentsFailure: (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    },\n    uploadDocumentStart: state => {\n      state.loading = true;\n      state.error = null;\n    },\n    uploadDocumentSuccess: (state, action) => {\n      state.loading = false;\n      state.documents = [...state.documents, action.payload];\n      state.currentDocument = action.payload;\n    },\n    uploadDocumentFailure: (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    },\n    analyzeDocumentStart: state => {\n      state.loading = true;\n      state.error = null;\n    },\n    analyzeDocumentSuccess: (state, action) => {\n      state.loading = false;\n      state.analysis = action.payload;\n    },\n    analyzeDocumentFailure: (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    },\n    setCurrentDocument: (state, action) => {\n      state.currentDocument = action.payload;\n    },\n    clearAnalysis: state => {\n      state.analysis = null;\n    },\n    clearError: state => {\n      state.error = null;\n    }\n  }\n});\nexport const {\n  fetchDocumentsStart,\n  fetchDocumentsSuccess,\n  fetchDocumentsFailure,\n  uploadDocumentStart,\n  uploadDocumentSuccess,\n  uploadDocumentFailure,\n  analyzeDocumentStart,\n  analyzeDocumentSuccess,\n  analyzeDocumentFailure,\n  setCurrentDocument,\n  clearAnalysis,\n  clearError\n} = documentSlice.actions;\n\n// Thunk actions\nexport const fetchDocuments = () => async dispatch => {\n  try {\n    dispatch(fetchDocumentsStart());\n    // In a real app, this would call the API service\n    // const response = await documentService.getDocuments();\n\n    // Simulate API call for demo\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    const response = [{\n      id: '1',\n      title: 'Employment Contract',\n      description: 'Standard employment agreement',\n      file_path: '/documents/employment_contract.pdf',\n      file_type: 'pdf',\n      status: 'analyzed',\n      created_at: new Date().toISOString()\n    }, {\n      id: '2',\n      title: 'Non-Disclosure Agreement',\n      description: 'Confidentiality agreement for project X',\n      file_path: '/documents/nda.pdf',\n      file_type: 'pdf',\n      status: 'uploaded',\n      created_at: new Date().toISOString()\n    }];\n    dispatch(fetchDocumentsSuccess(response));\n    return response;\n  } catch (error) {\n    dispatch(fetchDocumentsFailure(error.message));\n    throw error;\n  }\n};\nexport const uploadDocument = (file, title, description) => async dispatch => {\n  try {\n    dispatch(uploadDocumentStart());\n    // In a real app, this would call the API service\n    // const response = await documentService.uploadDocument(file, title, description);\n\n    // Simulate API call for demo\n    await new Promise(resolve => setTimeout(resolve, 1500));\n    const response = {\n      id: Math.random().toString(36).substring(2, 9),\n      title,\n      description,\n      file_path: `/documents/${file.name}`,\n      file_type: file.name.split('.').pop(),\n      status: 'uploaded',\n      created_at: new Date().toISOString()\n    };\n    dispatch(uploadDocumentSuccess(response));\n    return response;\n  } catch (error) {\n    dispatch(uploadDocumentFailure(error.message));\n    throw error;\n  }\n};\nexport const analyzeDocument = (documentId, llmModel) => async dispatch => {\n  try {\n    dispatch(analyzeDocumentStart());\n    // In a real app, this would call the API service\n    // const response = await documentService.analyzeDocument(documentId, llmModel);\n\n    // Simulate API call for demo\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    const response = {\n      document_id: documentId,\n      summary: \"This contract outlines a service agreement between ABC Corp and XYZ Inc for software development services.\",\n      key_points: [\"Initial term of 12 months with automatic renewal\", \"Payment terms: Net 30 days\", \"Includes confidentiality and non-compete clauses\", \"Intellectual property rights assigned to client\"],\n      entities: {\n        people: [\"John Smith (CEO)\", \"Jane Doe (CTO)\"],\n        organizations: [\"ABC Corporation\", \"XYZ Inc\"],\n        dates: [\"January 15, 2025\", \"December 31, 2025\"]\n      },\n      recommendations: [\"Review section 3.2 regarding payment terms\", \"Consider adding more specific deliverable timelines\", \"Strengthen the dispute resolution mechanism\"],\n      llm_model: llmModel\n    };\n    dispatch(analyzeDocumentSuccess(response));\n    return response;\n  } catch (error) {\n    dispatch(analyzeDocumentFailure(error.message));\n    throw error;\n  }\n};\nexport default documentSlice.reducer;","map":{"version":3,"names":["createSlice","initialState","documents","currentDocument","analysis","loading","error","documentSlice","name","reducers","fetchDocumentsStart","state","fetchDocumentsSuccess","action","payload","fetchDocumentsFailure","uploadDocumentStart","uploadDocumentSuccess","uploadDocumentFailure","analyzeDocumentStart","analyzeDocumentSuccess","analyzeDocumentFailure","setCurrentDocument","clearAnalysis","clearError","actions","fetchDocuments","dispatch","Promise","resolve","setTimeout","response","id","title","description","file_path","file_type","status","created_at","Date","toISOString","message","uploadDocument","file","Math","random","toString","substring","split","pop","analyzeDocument","documentId","llmModel","document_id","summary","key_points","entities","people","organizations","dates","recommendations","llm_model","reducer"],"sources":["/Users/venkata/startup/legal_app/frontend/src/store/documentSlice.js"],"sourcesContent":["import { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = {\n  documents: [],\n  currentDocument: null,\n  analysis: null,\n  loading: false,\n  error: null\n};\n\nexport const documentSlice = createSlice({\n  name: 'document',\n  initialState,\n  reducers: {\n    fetchDocumentsStart: (state) => {\n      state.loading = true;\n      state.error = null;\n    },\n    fetchDocumentsSuccess: (state, action) => {\n      state.loading = false;\n      state.documents = action.payload;\n    },\n    fetchDocumentsFailure: (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    },\n    uploadDocumentStart: (state) => {\n      state.loading = true;\n      state.error = null;\n    },\n    uploadDocumentSuccess: (state, action) => {\n      state.loading = false;\n      state.documents = [...state.documents, action.payload];\n      state.currentDocument = action.payload;\n    },\n    uploadDocumentFailure: (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    },\n    analyzeDocumentStart: (state) => {\n      state.loading = true;\n      state.error = null;\n    },\n    analyzeDocumentSuccess: (state, action) => {\n      state.loading = false;\n      state.analysis = action.payload;\n    },\n    analyzeDocumentFailure: (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    },\n    setCurrentDocument: (state, action) => {\n      state.currentDocument = action.payload;\n    },\n    clearAnalysis: (state) => {\n      state.analysis = null;\n    },\n    clearError: (state) => {\n      state.error = null;\n    }\n  }\n});\n\nexport const {\n  fetchDocumentsStart,\n  fetchDocumentsSuccess,\n  fetchDocumentsFailure,\n  uploadDocumentStart,\n  uploadDocumentSuccess,\n  uploadDocumentFailure,\n  analyzeDocumentStart,\n  analyzeDocumentSuccess,\n  analyzeDocumentFailure,\n  setCurrentDocument,\n  clearAnalysis,\n  clearError\n} = documentSlice.actions;\n\n// Thunk actions\nexport const fetchDocuments = () => async (dispatch) => {\n  try {\n    dispatch(fetchDocumentsStart());\n    // In a real app, this would call the API service\n    // const response = await documentService.getDocuments();\n    \n    // Simulate API call for demo\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    const response = [\n      {\n        id: '1',\n        title: 'Employment Contract',\n        description: 'Standard employment agreement',\n        file_path: '/documents/employment_contract.pdf',\n        file_type: 'pdf',\n        status: 'analyzed',\n        created_at: new Date().toISOString()\n      },\n      {\n        id: '2',\n        title: 'Non-Disclosure Agreement',\n        description: 'Confidentiality agreement for project X',\n        file_path: '/documents/nda.pdf',\n        file_type: 'pdf',\n        status: 'uploaded',\n        created_at: new Date().toISOString()\n      }\n    ];\n    \n    dispatch(fetchDocumentsSuccess(response));\n    return response;\n  } catch (error) {\n    dispatch(fetchDocumentsFailure(error.message));\n    throw error;\n  }\n};\n\nexport const uploadDocument = (file, title, description) => async (dispatch) => {\n  try {\n    dispatch(uploadDocumentStart());\n    // In a real app, this would call the API service\n    // const response = await documentService.uploadDocument(file, title, description);\n    \n    // Simulate API call for demo\n    await new Promise(resolve => setTimeout(resolve, 1500));\n    const response = {\n      id: Math.random().toString(36).substring(2, 9),\n      title,\n      description,\n      file_path: `/documents/${file.name}`,\n      file_type: file.name.split('.').pop(),\n      status: 'uploaded',\n      created_at: new Date().toISOString()\n    };\n    \n    dispatch(uploadDocumentSuccess(response));\n    return response;\n  } catch (error) {\n    dispatch(uploadDocumentFailure(error.message));\n    throw error;\n  }\n};\n\nexport const analyzeDocument = (documentId, llmModel) => async (dispatch) => {\n  try {\n    dispatch(analyzeDocumentStart());\n    // In a real app, this would call the API service\n    // const response = await documentService.analyzeDocument(documentId, llmModel);\n    \n    // Simulate API call for demo\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    const response = {\n      document_id: documentId,\n      summary: \"This contract outlines a service agreement between ABC Corp and XYZ Inc for software development services.\",\n      key_points: [\n        \"Initial term of 12 months with automatic renewal\",\n        \"Payment terms: Net 30 days\",\n        \"Includes confidentiality and non-compete clauses\",\n        \"Intellectual property rights assigned to client\"\n      ],\n      entities: {\n        people: [\"John Smith (CEO)\", \"Jane Doe (CTO)\"],\n        organizations: [\"ABC Corporation\", \"XYZ Inc\"],\n        dates: [\"January 15, 2025\", \"December 31, 2025\"]\n      },\n      recommendations: [\n        \"Review section 3.2 regarding payment terms\",\n        \"Consider adding more specific deliverable timelines\",\n        \"Strengthen the dispute resolution mechanism\"\n      ],\n      llm_model: llmModel\n    };\n    \n    dispatch(analyzeDocumentSuccess(response));\n    return response;\n  } catch (error) {\n    dispatch(analyzeDocumentFailure(error.message));\n    throw error;\n  }\n};\n\nexport default documentSlice.reducer;\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,kBAAkB;AAE9C,MAAMC,YAAY,GAAG;EACnBC,SAAS,EAAE,EAAE;EACbC,eAAe,EAAE,IAAI;EACrBC,QAAQ,EAAE,IAAI;EACdC,OAAO,EAAE,KAAK;EACdC,KAAK,EAAE;AACT,CAAC;AAED,OAAO,MAAMC,aAAa,GAAGP,WAAW,CAAC;EACvCQ,IAAI,EAAE,UAAU;EAChBP,YAAY;EACZQ,QAAQ,EAAE;IACRC,mBAAmB,EAAGC,KAAK,IAAK;MAC9BA,KAAK,CAACN,OAAO,GAAG,IAAI;MACpBM,KAAK,CAACL,KAAK,GAAG,IAAI;IACpB,CAAC;IACDM,qBAAqB,EAAEA,CAACD,KAAK,EAAEE,MAAM,KAAK;MACxCF,KAAK,CAACN,OAAO,GAAG,KAAK;MACrBM,KAAK,CAACT,SAAS,GAAGW,MAAM,CAACC,OAAO;IAClC,CAAC;IACDC,qBAAqB,EAAEA,CAACJ,KAAK,EAAEE,MAAM,KAAK;MACxCF,KAAK,CAACN,OAAO,GAAG,KAAK;MACrBM,KAAK,CAACL,KAAK,GAAGO,MAAM,CAACC,OAAO;IAC9B,CAAC;IACDE,mBAAmB,EAAGL,KAAK,IAAK;MAC9BA,KAAK,CAACN,OAAO,GAAG,IAAI;MACpBM,KAAK,CAACL,KAAK,GAAG,IAAI;IACpB,CAAC;IACDW,qBAAqB,EAAEA,CAACN,KAAK,EAAEE,MAAM,KAAK;MACxCF,KAAK,CAACN,OAAO,GAAG,KAAK;MACrBM,KAAK,CAACT,SAAS,GAAG,CAAC,GAAGS,KAAK,CAACT,SAAS,EAAEW,MAAM,CAACC,OAAO,CAAC;MACtDH,KAAK,CAACR,eAAe,GAAGU,MAAM,CAACC,OAAO;IACxC,CAAC;IACDI,qBAAqB,EAAEA,CAACP,KAAK,EAAEE,MAAM,KAAK;MACxCF,KAAK,CAACN,OAAO,GAAG,KAAK;MACrBM,KAAK,CAACL,KAAK,GAAGO,MAAM,CAACC,OAAO;IAC9B,CAAC;IACDK,oBAAoB,EAAGR,KAAK,IAAK;MAC/BA,KAAK,CAACN,OAAO,GAAG,IAAI;MACpBM,KAAK,CAACL,KAAK,GAAG,IAAI;IACpB,CAAC;IACDc,sBAAsB,EAAEA,CAACT,KAAK,EAAEE,MAAM,KAAK;MACzCF,KAAK,CAACN,OAAO,GAAG,KAAK;MACrBM,KAAK,CAACP,QAAQ,GAAGS,MAAM,CAACC,OAAO;IACjC,CAAC;IACDO,sBAAsB,EAAEA,CAACV,KAAK,EAAEE,MAAM,KAAK;MACzCF,KAAK,CAACN,OAAO,GAAG,KAAK;MACrBM,KAAK,CAACL,KAAK,GAAGO,MAAM,CAACC,OAAO;IAC9B,CAAC;IACDQ,kBAAkB,EAAEA,CAACX,KAAK,EAAEE,MAAM,KAAK;MACrCF,KAAK,CAACR,eAAe,GAAGU,MAAM,CAACC,OAAO;IACxC,CAAC;IACDS,aAAa,EAAGZ,KAAK,IAAK;MACxBA,KAAK,CAACP,QAAQ,GAAG,IAAI;IACvB,CAAC;IACDoB,UAAU,EAAGb,KAAK,IAAK;MACrBA,KAAK,CAACL,KAAK,GAAG,IAAI;IACpB;EACF;AACF,CAAC,CAAC;AAEF,OAAO,MAAM;EACXI,mBAAmB;EACnBE,qBAAqB;EACrBG,qBAAqB;EACrBC,mBAAmB;EACnBC,qBAAqB;EACrBC,qBAAqB;EACrBC,oBAAoB;EACpBC,sBAAsB;EACtBC,sBAAsB;EACtBC,kBAAkB;EAClBC,aAAa;EACbC;AACF,CAAC,GAAGjB,aAAa,CAACkB,OAAO;;AAEzB;AACA,OAAO,MAAMC,cAAc,GAAGA,CAAA,KAAM,MAAOC,QAAQ,IAAK;EACtD,IAAI;IACFA,QAAQ,CAACjB,mBAAmB,CAAC,CAAC,CAAC;IAC/B;IACA;;IAEA;IACA,MAAM,IAAIkB,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;IACvD,MAAME,QAAQ,GAAG,CACf;MACEC,EAAE,EAAE,GAAG;MACPC,KAAK,EAAE,qBAAqB;MAC5BC,WAAW,EAAE,+BAA+B;MAC5CC,SAAS,EAAE,oCAAoC;MAC/CC,SAAS,EAAE,KAAK;MAChBC,MAAM,EAAE,UAAU;MAClBC,UAAU,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;IACrC,CAAC,EACD;MACER,EAAE,EAAE,GAAG;MACPC,KAAK,EAAE,0BAA0B;MACjCC,WAAW,EAAE,yCAAyC;MACtDC,SAAS,EAAE,oBAAoB;MAC/BC,SAAS,EAAE,KAAK;MAChBC,MAAM,EAAE,UAAU;MAClBC,UAAU,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;IACrC,CAAC,CACF;IAEDb,QAAQ,CAACf,qBAAqB,CAACmB,QAAQ,CAAC,CAAC;IACzC,OAAOA,QAAQ;EACjB,CAAC,CAAC,OAAOzB,KAAK,EAAE;IACdqB,QAAQ,CAACZ,qBAAqB,CAACT,KAAK,CAACmC,OAAO,CAAC,CAAC;IAC9C,MAAMnC,KAAK;EACb;AACF,CAAC;AAED,OAAO,MAAMoC,cAAc,GAAGA,CAACC,IAAI,EAAEV,KAAK,EAAEC,WAAW,KAAK,MAAOP,QAAQ,IAAK;EAC9E,IAAI;IACFA,QAAQ,CAACX,mBAAmB,CAAC,CAAC,CAAC;IAC/B;IACA;;IAEA;IACA,MAAM,IAAIY,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;IACvD,MAAME,QAAQ,GAAG;MACfC,EAAE,EAAEY,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;MAC9Cd,KAAK;MACLC,WAAW;MACXC,SAAS,EAAE,cAAcQ,IAAI,CAACnC,IAAI,EAAE;MACpC4B,SAAS,EAAEO,IAAI,CAACnC,IAAI,CAACwC,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,CAAC;MACrCZ,MAAM,EAAE,UAAU;MAClBC,UAAU,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;IACrC,CAAC;IAEDb,QAAQ,CAACV,qBAAqB,CAACc,QAAQ,CAAC,CAAC;IACzC,OAAOA,QAAQ;EACjB,CAAC,CAAC,OAAOzB,KAAK,EAAE;IACdqB,QAAQ,CAACT,qBAAqB,CAACZ,KAAK,CAACmC,OAAO,CAAC,CAAC;IAC9C,MAAMnC,KAAK;EACb;AACF,CAAC;AAED,OAAO,MAAM4C,eAAe,GAAGA,CAACC,UAAU,EAAEC,QAAQ,KAAK,MAAOzB,QAAQ,IAAK;EAC3E,IAAI;IACFA,QAAQ,CAACR,oBAAoB,CAAC,CAAC,CAAC;IAChC;IACA;;IAEA;IACA,MAAM,IAAIS,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;IACvD,MAAME,QAAQ,GAAG;MACfsB,WAAW,EAAEF,UAAU;MACvBG,OAAO,EAAE,4GAA4G;MACrHC,UAAU,EAAE,CACV,kDAAkD,EAClD,4BAA4B,EAC5B,kDAAkD,EAClD,iDAAiD,CAClD;MACDC,QAAQ,EAAE;QACRC,MAAM,EAAE,CAAC,kBAAkB,EAAE,gBAAgB,CAAC;QAC9CC,aAAa,EAAE,CAAC,iBAAiB,EAAE,SAAS,CAAC;QAC7CC,KAAK,EAAE,CAAC,kBAAkB,EAAE,mBAAmB;MACjD,CAAC;MACDC,eAAe,EAAE,CACf,4CAA4C,EAC5C,qDAAqD,EACrD,6CAA6C,CAC9C;MACDC,SAAS,EAAET;IACb,CAAC;IAEDzB,QAAQ,CAACP,sBAAsB,CAACW,QAAQ,CAAC,CAAC;IAC1C,OAAOA,QAAQ;EACjB,CAAC,CAAC,OAAOzB,KAAK,EAAE;IACdqB,QAAQ,CAACN,sBAAsB,CAACf,KAAK,CAACmC,OAAO,CAAC,CAAC;IAC/C,MAAMnC,KAAK;EACb;AACF,CAAC;AAED,eAAeC,aAAa,CAACuD,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}